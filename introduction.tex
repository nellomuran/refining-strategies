Nondeterministic strategies (a.k.a. plans or protocols) are strategies
that associate to the current history a \emph{set of alternative
  moves} (instead of one) all of which are ``good'' for the objective
of the strategy.
%%
Nondeterministic strategies have been studied in literature in several
contexts.
%%
Possibly the most relevant area is Discrete Event Control where a
central notion is that of \emph{maximally permissive supervisor}
\cite{WonhamRamadge:SIAMJCO87,Cassandras:BOOK06_DES,Wo14}. This is
supervisor that controls a plant, i.e., allows the plant to do only
certain operations at each point in time. Note that this supervisor
does not says exactly what to do to the plant (as a deterministic
strategy) but in fact tries to leave as much freedom as possible to
plant itself blocking only operations that are unsafe. In fact it is
of interest to be \emph{maximally permissive} wrt the plant. 
Indeed the central result of Discrete Control Theory is that such a
maximally permissive supervisor, i.e., nondeterministic strategy
always exists if the plant and the supervisor specifications are
expressed as regular languages. Such a notion has attracted the interest
of the reasoning about actions community
]\cite{DeGiacomoLM12,BanihashemiGL-AAMAS18} and of the reactive program
synthesis community \cite{pnueli1989synthesisshort,EhlersLTV17}.


Another interesting case is that controllers that orchestrate several components to compose a desired global behaviour \cite{DePS13,DeGiacomoVFAL18}. One way of seeing this is that the controller tries to maintain over time a sort of simulation relation between the desired behavior expressed as a transition system and the Cartesian product of the transitino systems of the components. Also in this case the notion of maximally permissive nondeterministic strategy arises \cite{DePS13}.


Nondeterministic strategies are also of interest in planning \cite{GeffnerBo13}.  Action preconditions themselves can be though of as generating a nondeterministic strategy  as a function that given the state of the domain returns a set of possible actions. 

Also module checking can be considered as dealing with nondeterministic strategies of the environment \cite{kupferman1997module,jamroga2014module}. In the basic setting, module checking concerns the model checking problem of an open system, i.e., a system interacting continuously with its unpredictable environment, against a branching-time specification. This interaction can be seen as a game between the system and the environment, where the latter, along a play, at its own turn, choses some of the possible available successors, while the former, at its own turn, takes all possible ones. Therefore, while model checking concerns checking that the unique possible evolution of the system (a tree) satisfies the specification, in module checking one has to check that the specification holds over all the possible evolutions coming from the interaction of the system with the environment.

An important problem is that of refining
  such strategies. For instance, given a nondeterministic strategy
  that allows only safe executions, refine it to, additionally,
  eventually reach a desired state of affairs.  In this paper, we show that such
  problems can be solved elegantly in the framework of Strategy Logic
  (SL), a very expressive logic to reason about strategic
  abilities \cite{chatterjee2010strategy,DBLP:journals/tocl/MogaveroMPV14,DBLP:conf/lics/MogaveroMS13,BMMRV17}. Specifically, we introduce a variant of SL with
  nondeterministic strategies and a strategy refinement operator. We
  show that model checking this logic can be done at no additional
  computational cost with respect to standard SL, and can be used to
  solve problems synthesis, synthesis of most permissive strategies,
  module checking, and more.

\bam{Talk about controller synthesis (traditionally use
  nondeterministic strategies and
  look for maximal permissive ones)}  

see:
\begin{itemize}
\item Julien Bernet, David Janin, and Igor Walukiewicz. Permissive
  strategies:from parity games to safety games

  $\rightarrow$ shows that in parity games we can compute winning nondeterministic
  strategies that are more permissive than all memoryless winning strategies
\item Patricia Bouyer, Marie Duflot, Nicolas Markey, and Gabriel
  Renault. Measuring permissivity in finite games

  $\rightarrow$ quantitative notion of permissiveness: to each action in
  each state is associated a number representing the \emph{penalty}
  incurred by a strategy that disallows this action. Permissiveness of
  a strategy is then the supremum over all outcomes of the mean
  penalty along this outcome.
  
\item Patricia Bouyer, Nicolas Markey, Jörg Olschewski and Michael
  Ummels. Measuring permissiveness inparity games: Mean-payoff parity
  games revisited

  $\rightarrow$ generalisation to parity games
  
\item Sophie Pinchinat and Stéphane Riedweg. You can always compute
  maximally permissive controllers under partial observation when they
  exist
  
$\rightarrow$   for branching mu-calculus

  
\item Michael Luttenberger. Strategy iteration using non-deterministic
  strategies for solving parity games  

$\rightarrow$ solving parity games with nondeterministic strategies

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
